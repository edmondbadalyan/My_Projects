1  Бадалян Эдмонд Варужанович
2  ООП - объектно - ориентированное программирование, парадигма структурирования кода,
создание на его основе классов, и объектов, и способов их взаимодействия.

3  Три правила ООП - инкапсуляция, наследование, полиморфизм.
Инкапсуляция, организация кода в виде черного ящика, нам не известно что происходит внутри него, мы получаем
нужный ответ из веденных данных.
Наследование - организация взаимосвязи классов, при котором есть родительский и дочерние от него классы,
при котором у дочерних классов есть доступ к определенным данным родителя.
Полиморфизм - общий интерфейс взаимодействия между классами, в виде методов и функций, различными наборами параметров в одном
классе или группе классов, связанных наследованием.

4  Методы и Поля - это члены класса в ООП, поля это переменые которые хранят данные объекта, они могут быть разных типов.
Методы это функции которые определяют поведение обьекта, они могут использовать поле обьекта для своих задач.

5 Конструктор это метод класса который вызывается при создании объекта этого класса, он используется для корректной
инициализации полей класса.Person(string name, int age) { this.name = name; this.age = age; }
Деструктор это метод класса который вызывается для удаление данных в случае их выделения например оператором new,
и высвобождения ресурсов. ~Person{ delete[] data; }

6 Инициализация при объявлении : int x = 0;
Инициализация в конструкторе :
class Myclass {
public:
    int x;
    string name;
    Myclass(int a, string n) {
        x = a;
        name = n;
    }
};
также Myclass(int a, string n) : x(a), name(n) {}

7 Это конструктор, который вызывает другой конструктор, для инициализации части кода.
Myclass(); -конструктор по умолчанию.
Myclass(int age, string name) : age(age), name(name);
первый конструктор делегирует второму инициализацю полей.

8  this является указателем, на текущий объекта класса.
Используется для доступов к членам класса.
Для выводы данных в виде this->name, или для возврата ссылки на текущий объект return *this;

9 Копирование используется для создания нового объекта, который является копией, уже существующего объекта.
Myclass(const Myclass & other) : name(other.name), age(other.age) {}
это требуется для корректного копирования, а не создания копии по умолчанию которая была бы независима от нашего объекта.

10 const нужно для неизменяемости данных, использование или доступ к данным которые мы не хотим менять.
explicit нужен в случае если нам явно нужно указывать тип передаваемого объекта, объяление его с конструктором
означает что при создании объекта с помощью конструктора, надо явно указывать тип данных.

11 Перегрузка операторов, позволяет определить новые свойства для стандарнтных операторов.
Myclass operator+(const Myclass & other)const {
    Myclass result;
    result.x = x + other.x;
    result.y = y + other.y;
    return result;
}
перерузка возможна со всеми операторами пример, +, -, *, / , %, +=, -=, *=, /=, %=, и тд

12 Перемещение это создание нового объекта путем перемещения данных из уже существующего объекта, без копирования.

13 Это механизм получения доступа к закрытым членам класса.
Объявляя функцию дружественной с ключевым словом friend мы получаем доступ к приватным членам класса.
Обявляя класс дружественным, указывая его в приватном поле, мы также даем ему доступ к приватным членам класса.
class Myclass {
private:
    MyfriendClass;

};
14 Они позволяют создавать обобщенные классы для работы с разными типами данных.
Template <typename T>
class vector {};

int main() {
    vector <int>;
    vector <double>;

    return 0;
}

15 Это структуры данных, в стеке вынимается первым последний добавленый объект, в очереди извлекается первым объект
которым первым и был добавлен в нее.

int main() {
    stack<int> mystack; 

    mystack.push(10); 
    mystack.push(20);
    mystack.push(30);

    cout << "Top element: " << mystack.top();

    mystack.pop(); 
    cout << "Top element after pop: " << mystack.top();

    return 0;
}


